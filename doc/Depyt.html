<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Depyt" rel="Chapter" href="Depyt.html"><link title="Depyt" rel="Section" href="#1_Depyt">
<link title="Primitives" rel="Section" href="#primitives">
<link title="Records" rel="Section" href="#records">
<link title="Variants" rel="Section" href="#variants">
<link title="Recursive definitions" rel="Section" href="#recursive">
<link title="Generic Operations" rel="Section" href="#generics">
<link title="Binary serialization" rel="Subsection" href="#2_Binaryserialization">
<link title="JSON converters" rel="Subsection" href="#2_JSONconverters">
<title>Depyt</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;</div>
<h1>Module <a href="type_Depyt.html">Depyt</a></h1>

<pre><span class="keyword">module</span> Depyt: <code class="code"><span class="keyword">sig</span></code> <a href="Depyt.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
Yet-an-other type combinator library
<p>

    <code class="code"><span class="constructor">Depyt</span></code> provides type combinators to define runtime representation
    for OCaml types and <a href="Depyt.html#generics">generic operations</a> to manipulate
    values with a runtime type representation.
<p>

    The type combinators supports all the usual <a href="Depyt.html#primitives">type
    primitives</a> but also compact definitions of <a href="Depyt.html#records">records</a>
    and <a href="Depyt.html#variants">variants</a>. It also allows to define the runtime
    representation of <a href="Depyt.html#recursive">recursive types</a>.
<p>

    <code class="code"><span class="constructor">Depyt</span></code> is a modern reboot of
    <a href="https://github.com/mirage/dyntype">Dyntype</a> but using
    <a href="https://en.wikipedia.org/wiki/Generalized_algebraic_data_type">GADT</a>s-based
    combinators instead of syntax-extensions. When we originally wrote
    <code class="code"><span class="constructor">Dyntype</span></code> (in 2012) GADTs were not available in <i>OCaml</i> and
    <a href="https://github.com/ocaml/camlp4">camlp4</a> was everywhere -- this
    is not the case anymore. Finally, <code class="code"><span class="constructor">Depyt</span></code> avoids some of the
    performance caveats present in <code class="code"><span class="constructor">Dyntype</span></code> by avoiding allocating
    and converting between intermediate formats.
<p>

    <em>ad39af4 â€” <a href="https://github.com/samoht/depyt ">homepage</a></em><br>
</div>
<hr width="100%">
<br>
<h1 id="1_Depyt">Depyt</h1><br>

<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type">'a</code> t</span> </pre>
<div class="info ">
The type for runtime representation of values of type <code class="code"><span class="keywordsign">'</span>a</code>.<br>
</div>

<br>
<h1 id="primitives">Primitives</h1><br>

<pre><span id="VALunit"><span class="keyword">val</span> unit</span> : <code class="type">unit <a href="Depyt.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">unit</code> is a representation of the unit type.<br>
</div>

<pre><span id="VALbool"><span class="keyword">val</span> bool</span> : <code class="type">bool <a href="Depyt.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">bool</code> is a representation of the boolean type.<br>
</div>

<pre><span id="VALchar"><span class="keyword">val</span> char</span> : <code class="type">char <a href="Depyt.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">char</code> is a representation of the character type.<br>
</div>

<pre><span id="VALint"><span class="keyword">val</span> int</span> : <code class="type">int <a href="Depyt.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">int</code> is a representation of the integer type.<br>
</div>

<pre><span id="VALint32"><span class="keyword">val</span> int32</span> : <code class="type">int32 <a href="Depyt.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">int32</code> is a representation of the 32-bit integers type.<br>
</div>

<pre><span id="VALint64"><span class="keyword">val</span> int64</span> : <code class="type">int64 <a href="Depyt.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">int64</code> is a representation of the 64-bit integer type.<br>
</div>

<pre><span id="VALfloat"><span class="keyword">val</span> float</span> : <code class="type">float <a href="Depyt.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">float</code> is a representation of the float type.<br>
</div>

<pre><span id="VALstring"><span class="keyword">val</span> string</span> : <code class="type">string <a href="Depyt.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">string</code> is a representation of the string type.<br>
</div>

<pre><span id="VALlist"><span class="keyword">val</span> list</span> : <code class="type">'a <a href="Depyt.html#TYPEt">t</a> -> 'a list <a href="Depyt.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">list t</code> is a representation of list of values of type <code class="code">t</code>.<br>
</div>

<pre><span id="VALoption"><span class="keyword">val</span> option</span> : <code class="type">'a <a href="Depyt.html#TYPEt">t</a> -> 'a option <a href="Depyt.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">option t</code> is a representation of value of type <code class="code">t option</code>.<br>
</div>

<pre><span id="VALpair"><span class="keyword">val</span> pair</span> : <code class="type">'a <a href="Depyt.html#TYPEt">t</a> -> 'b <a href="Depyt.html#TYPEt">t</a> -> ('a * 'b) <a href="Depyt.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">pair x y</code> is a representation of values of type <code class="code">x * y</code>.<br>
</div>
<br>
<h1 id="records">Records</h1><br>

<pre><span id="TYPEfield"><span class="keyword">type</span> <code class="type">('a, 'b)</code> field</span> </pre>
<div class="info ">
The type for fields holding values of type <code class="code"><span class="keywordsign">'</span>b</code> and belonging to a
    record of type <code class="code"><span class="keywordsign">'</span>a</code>.<br>
</div>


<pre><span id="VALfield"><span class="keyword">val</span> field</span> : <code class="type">string -> 'a <a href="Depyt.html#TYPEt">t</a> -> ('b -> 'a) -> ('b, 'a) <a href="Depyt.html#TYPEfield">field</a></code></pre><div class="info ">
<code class="code">field n t g</code> is the representation of the field <code class="code">n</code> of type <code class="code">t</code>
    with getter <code class="code">g</code>.
<p>

    For instance:
<p>

    <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">type</span>&nbsp;t&nbsp;=&nbsp;{&nbsp;foo:&nbsp;string&nbsp;option&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;foo&nbsp;=&nbsp;field&nbsp;<span class="string">"foo"</span>&nbsp;(option&nbsp;string)&nbsp;(<span class="keyword">fun</span>&nbsp;t&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;t.x)</code></pre><br>
</div>

<pre><span id="TYPEopen_record"><span class="keyword">type</span> <code class="type">('a, 'b, 'c)</code> open_record</span> </pre>
<div class="info ">
The type for representing open records of type <code class="code"><span class="keywordsign">'</span>a</code> with
    constructors of type <code class="code"><span class="keywordsign">'</span>b</code>. <code class="code"><span class="keywordsign">'</span>c</code> represents the fields missings to
    the record, e.g. an open record initially holds <code class="code"><span class="keywordsign">'</span>c = <span class="keywordsign">'</span>b</code> and it
    can can be <a href="Depyt.html#VALsealr">sealed</a> when <code class="code"><span class="keywordsign">'</span>c = <span class="keywordsign">'</span>a</code>.<br>
</div>


<pre><span id="VALsealr"><span class="keyword">val</span> sealr</span> : <code class="type">('a, 'b, 'a) <a href="Depyt.html#TYPEopen_record">open_record</a> -> 'a <a href="Depyt.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">sealr r</code> seal the open record <code class="code">r</code>.<br>
</div>

<pre><span id="VAL(|+)"><span class="keyword">val</span> (|+)</span> : <code class="type">('a, 'b, 'c -> 'd) <a href="Depyt.html#TYPEopen_record">open_record</a> -><br>       ('a, 'c) <a href="Depyt.html#TYPEfield">field</a> -> ('a, 'b, 'd) <a href="Depyt.html#TYPEopen_record">open_record</a></code></pre><div class="info ">
<code class="code">r |+ f</code> adds the field <code class="code">f</code> to the open record <code class="code">r</code>.<br>
</div>

<pre><span id="VALrecord"><span class="keyword">val</span> record</span> : <code class="type">string -> 'b -> ('a, 'b, 'b) <a href="Depyt.html#TYPEopen_record">open_record</a></code></pre><div class="info ">
<code class="code">record n f fs</code> is the representation of the record called <code class="code">n</code> of
    type <code class="code"><span class="keywordsign">'</span>a</code> using <code class="code">f</code> as constructor and with the fields <code class="code">fs</code>.
<p>

    Putting all together:
<p>

    <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">type</span>&nbsp;t&nbsp;=&nbsp;{&nbsp;foo:&nbsp;string;&nbsp;bar&nbsp;=&nbsp;(int&nbsp;*&nbsp;string)&nbsp;list;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;t&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;record&nbsp;<span class="string">"t"</span>&nbsp;(<span class="keyword">fun</span>&nbsp;foo&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;{&nbsp;foo&nbsp;})
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|+&nbsp;field&nbsp;<span class="string">"foo"</span>&nbsp;string&nbsp;(<span class="keyword">fun</span>&nbsp;t&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;t.foo)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|+&nbsp;field&nbsp;<span class="string">"bar"</span>&nbsp;(list&nbsp;(pair&nbsp;int&nbsp;string))&nbsp;(<span class="keyword">fun</span>&nbsp;t&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;t.bar)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;sealr</code></pre><br>
</div>
<br>
<h1 id="variants">Variants</h1><br>

<pre><span id="TYPEcase"><span class="keyword">type</span> <code class="type">('a, 'b)</code> case</span> </pre>
<div class="info ">
The type for representing variant cases of type <code class="code"><span class="keywordsign">'</span>a</code> with
    patterns of type <code class="code"><span class="keywordsign">'</span>b</code>.<br>
</div>


<pre><span id="TYPEcase_p"><span class="keyword">type</span> <code class="type">'a</code> case_p</span> </pre>
<div class="info ">
The type for representing patterns for a variant of type <code class="code"><span class="keywordsign">'</span>a</code>.<br>
</div>


<pre><span id="VALcase0"><span class="keyword">val</span> case0</span> : <code class="type">string -> 'a -> ('a, 'a <a href="Depyt.html#TYPEcase_p">case_p</a>) <a href="Depyt.html#TYPEcase">case</a></code></pre><div class="info ">
<code class="code">case0 n v</code> is a representation of a variant case <code class="code">n</code> with no
    argument and a singleton pattern. e.g.
<p>

    <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">type</span>&nbsp;t&nbsp;=&nbsp;<span class="constructor">Foo</span>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;foo&nbsp;=&nbsp;case0&nbsp;<span class="string">"Foo"</span>&nbsp;<span class="constructor">Foo</span></code></pre><br>
</div>

<pre><span id="VALcase1"><span class="keyword">val</span> case1</span> : <code class="type">string -> 'b <a href="Depyt.html#TYPEt">t</a> -> ('b -> 'a) -> ('a, 'b -> 'a <a href="Depyt.html#TYPEcase_p">case_p</a>) <a href="Depyt.html#TYPEcase">case</a></code></pre><div class="info ">
<code class="code">case1 n t c</code> is a representation of a variant case <code class="code">n</code> with 1
    argument of type <code class="code">t</code> and a pattern <code class="code">c</code> an function with one argument
    of type <code class="code">t</code>. e.g.
<p>

    <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">type</span>&nbsp;t&nbsp;=&nbsp;<span class="constructor">Foo</span>&nbsp;<span class="keyword">of</span>&nbsp;string

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;foo&nbsp;=&nbsp;case1&nbsp;<span class="string">"Foo"</span>&nbsp;string&nbsp;(<span class="keyword">fun</span>&nbsp;s&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Foo</span>&nbsp;s)</code></pre><br>
</div>

<pre><span id="TYPEopen_variant"><span class="keyword">type</span> <code class="type">('a, 'b, 'c)</code> open_variant</span> </pre>
<div class="info ">
The type for representing open variants of type <code class="code"><span class="keywordsign">'</span>a</code> with pattern
    matching of type <code class="code"><span class="keywordsign">'</span>b</code>. <code class="code"><span class="keywordsign">'</span>c</code> represents the missing cases for the
    variant, e.g. initially variant hols <code class="code">c' = <span class="keywordsign">'</span>b</code> and it can be
    <a href="Depyt.html#VALsealv">sealed</a> when <code class="code"><span class="keywordsign">'</span>c = <span class="keywordsign">'</span>a</code>.<br>
</div>


<pre><span id="VALsealv"><span class="keyword">val</span> sealv</span> : <code class="type">('a, 'b, 'a -> 'a <a href="Depyt.html#TYPEcase_p">case_p</a>) <a href="Depyt.html#TYPEopen_variant">open_variant</a> -> 'a <a href="Depyt.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">sealv v</code> seals the open variant <code class="code">v</code>.<br>
</div>

<pre><span id="VAL(|~)"><span class="keyword">val</span> (|~)</span> : <code class="type">('a, 'b, 'c -> 'd) <a href="Depyt.html#TYPEopen_variant">open_variant</a> -><br>       ('a, 'c) <a href="Depyt.html#TYPEcase">case</a> -> ('a, 'b, 'd) <a href="Depyt.html#TYPEopen_variant">open_variant</a></code></pre><div class="info ">
<code class="code">v |~ c</code> is <code class="code">v</code> augmented with the case <code class="code">c</code>.<br>
</div>

<pre><span id="VALvariant"><span class="keyword">val</span> variant</span> : <code class="type">string -> 'b -> ('a, 'b, 'b) <a href="Depyt.html#TYPEopen_variant">open_variant</a></code></pre><div class="info ">
<code class="code">variant n c p</code> is a representation of a variant type containing
    the cases <code class="code">c</code> and using <code class="code">p</code> to deconstruct values.
<p>

    Putting all together:
<p>

    <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">type</span>&nbsp;t&nbsp;=&nbsp;<span class="constructor">Foo</span>&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Bar</span>&nbsp;<span class="keyword">of</span>&nbsp;string

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;t&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;variant&nbsp;<span class="string">"t"</span>&nbsp;(<span class="keyword">fun</span>&nbsp;foo&nbsp;bar&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="keyword">function</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Foo</span>&nbsp;&nbsp;&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;foo
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Bar</span>&nbsp;s&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;bar&nbsp;s)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|~&nbsp;case0&nbsp;<span class="string">"Foo"</span>&nbsp;<span class="constructor">Foo</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|~&nbsp;case1&nbsp;<span class="string">"Bar"</span>&nbsp;string&nbsp;(<span class="keyword">fun</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Bar</span>&nbsp;x)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;sealr</code></pre><br>
</div>

<pre><span id="VALenum"><span class="keyword">val</span> enum</span> : <code class="type">string -> (string * 'a) list -> 'a <a href="Depyt.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">enum n l</code> is a representation of the variant type which has
    only constant variant case. e.g.
<p>

    <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">type</span>&nbsp;t&nbsp;=&nbsp;<span class="constructor">Foo</span>&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Bar</span>&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Toto</span>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;t&nbsp;=&nbsp;enum&nbsp;<span class="string">"t"</span>&nbsp;[<span class="string">"Foo"</span>,&nbsp;<span class="constructor">Foo</span>;&nbsp;<span class="string">"Bar"</span>,&nbsp;<span class="constructor">Bar</span>;&nbsp;<span class="string">"Toto"</span>,&nbsp;<span class="constructor">Toto</span>]</code></pre><br>
</div>
<br>
<h1 id="recursive">Recursive definitions</h1>
<p>

    <code class="code"><span class="constructor">Depyt</span></code> allows to create a limited form of recursive records and
    variants.
<p>

    <b>TODO</b>: describe the limitations, e.g. only regular recursion and no
    use of the generics inside the <code class="code">mu*</code> functions and the usual
    caveats with recursive values (such as infinite loops on most of
    the generics which don't check sharing).<br>

<pre><span id="VALmu"><span class="keyword">val</span> mu</span> : <code class="type">('a <a href="Depyt.html#TYPEt">t</a> -> 'a <a href="Depyt.html#TYPEt">t</a>) -> 'a <a href="Depyt.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">mu f</code> is the representation <code class="code">r</code> such that <code class="code">r = mu r</code>.
<p>

    For instance:
<p>

    <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">type</span>&nbsp;x&nbsp;=&nbsp;{&nbsp;x:&nbsp;x&nbsp;option&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;mu&nbsp;(<span class="keyword">fun</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;record&nbsp;<span class="string">"x"</span>&nbsp;(<span class="keyword">fun</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;{&nbsp;x&nbsp;})
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|+&nbsp;field&nbsp;<span class="string">"x"</span>&nbsp;x&nbsp;(<span class="keyword">fun</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;x.x)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;sealr)</code></pre><br>
</div>

<pre><span id="VALmu2"><span class="keyword">val</span> mu2</span> : <code class="type">('a <a href="Depyt.html#TYPEt">t</a> -> 'b <a href="Depyt.html#TYPEt">t</a> -> 'a <a href="Depyt.html#TYPEt">t</a> * 'b <a href="Depyt.html#TYPEt">t</a>) -><br>       'a <a href="Depyt.html#TYPEt">t</a> * 'b <a href="Depyt.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">mu2 f</code> is the representations <code class="code">r</code> and <code class="code">s</code> such that <code class="code">r, s = mu2 r
    s</code>.
<p>

    For instance:
<p>

    <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">type</span>&nbsp;r&nbsp;=&nbsp;{&nbsp;foo:&nbsp;int;&nbsp;bar:&nbsp;string&nbsp;list;&nbsp;z:&nbsp;z&nbsp;option&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;z&nbsp;=&nbsp;{&nbsp;x:&nbsp;int;&nbsp;r:&nbsp;r&nbsp;list&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Build&nbsp;the&nbsp;representation&nbsp;of&nbsp;[r]&nbsp;knowing&nbsp;[z]'s.&nbsp;*)</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mkr&nbsp;z&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;record&nbsp;<span class="string">"r"</span>&nbsp;(<span class="keyword">fun</span>&nbsp;foo&nbsp;bar&nbsp;z&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;{&nbsp;foo;&nbsp;bar;&nbsp;z&nbsp;})
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|+&nbsp;field&nbsp;<span class="string">"foo"</span>&nbsp;int&nbsp;(<span class="keyword">fun</span>&nbsp;t&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;t.foo)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|+&nbsp;field&nbsp;<span class="string">"bar"</span>&nbsp;(list&nbsp;string)&nbsp;(<span class="keyword">fun</span>&nbsp;t&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;t.bar)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|+&nbsp;field&nbsp;<span class="string">"z"</span>&nbsp;(option&nbsp;z)&nbsp;(<span class="keyword">fun</span>&nbsp;t&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;t.z)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;sealr

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;And&nbsp;the&nbsp;representation&nbsp;of&nbsp;[z]&nbsp;knowing&nbsp;[r]'s.&nbsp;*)</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mkz&nbsp;r&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;record&nbsp;<span class="string">"z"</span>&nbsp;(<span class="keyword">fun</span>&nbsp;x&nbsp;r&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;{&nbsp;x;&nbsp;r&nbsp;})
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|+&nbsp;field&nbsp;<span class="string">"x"</span>&nbsp;int&nbsp;(<span class="keyword">fun</span>&nbsp;t&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;t.x)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|+&nbsp;field&nbsp;<span class="string">"r"</span>&nbsp;(list&nbsp;r)&nbsp;(<span class="keyword">fun</span>&nbsp;t&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;t.r)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;sealr

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Tie&nbsp;the&nbsp;loop.&nbsp;*)</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r,&nbsp;z&nbsp;=&nbsp;mu2&nbsp;(<span class="keyword">fun</span>&nbsp;r&nbsp;z&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;mkr&nbsp;z,&nbsp;mkz&nbsp;y)</code></pre><br>
</div>
<br>
<h1 id="generics">Generic Operations</h1>
<p>

    Given a value <code class="code"><span class="keywordsign">'</span>a t</code>, it is possible to define generic operations
    on value of type <code class="code"><span class="keywordsign">'</span>a</code> such as pretty-printing, parsing and
    unparsing.<br>

<pre><span id="VALpp"><span class="keyword">val</span> pp</span> : <code class="type">'a <a href="Depyt.html#TYPEt">t</a> -> 'a Fmt.t</code></pre><div class="info ">
<code class="code">pp t</code> is the pretty-printer for values of type <code class="code">t</code>.<br>
</div>

<pre><span id="VALequal"><span class="keyword">val</span> equal</span> : <code class="type">'a <a href="Depyt.html#TYPEt">t</a> -> 'a -> 'a -> bool</code></pre><div class="info ">
<code class="code">equal t</code> is the equality function between values of type <code class="code">t</code>.<br>
</div>

<pre><span id="VALcompare"><span class="keyword">val</span> compare</span> : <code class="type">'a <a href="Depyt.html#TYPEt">t</a> -> 'a -> 'a -> int</code></pre><div class="info ">
<code class="code">compare t</code> compares values of type <code class="code">t</code>.<br>
</div>
<br>
<h2 id="2_Binaryserialization">Binary serialization</h2><br>

<pre><code><span id="TYPEbuffer"><span class="keyword">type</span> <code class="type"></code>buffer</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbuffer.C"><span class="constructor">C</span></span> <span class="keyword">of</span> <code class="type">Cstruct.t</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbuffer.B"><span class="constructor">B</span></span> <span class="keyword">of</span> <code class="type">bytes</code></code></td>

</tr></table>

<div class="info ">
The type for buffers.<br>
</div>


<pre><span id="VALsize_of"><span class="keyword">val</span> size_of</span> : <code class="type">'a <a href="Depyt.html#TYPEt">t</a> -> 'a -> int</code></pre><div class="info ">
<code class="code">size_of t</code> is the size needed to serialize values of type <code class="code">t</code>.<br>
</div>

<pre><span id="VALwrite"><span class="keyword">val</span> write</span> : <code class="type">'a <a href="Depyt.html#TYPEt">t</a> -> <a href="Depyt.html#TYPEbuffer">buffer</a> -> pos:int -> 'a -> int</code></pre><div class="info ">
<code class="code">write t</code> serializes values of type <code class="code">t</code>. Use <code class="code">size_of</code> to
    pre-determine the size of the buffer.<br>
</div>

<pre><span id="VALread"><span class="keyword">val</span> read</span> : <code class="type">'a <a href="Depyt.html#TYPEt">t</a> -> <a href="Depyt.html#TYPEbuffer">buffer</a> -> pos:int -> int * 'a</code></pre><div class="info ">
<code class="code">read t</code> reads a serialization of a value of type <code class="code">t</code>.<br>
</div>
<br>
<h2 id="2_JSONconverters">JSON converters</h2><br>

<pre><span id="VALencode_json"><span class="keyword">val</span> encode_json</span> : <code class="type">'a <a href="Depyt.html#TYPEt">t</a> -> Jsonm.encoder -> 'a -> unit</code></pre><div class="info ">
<code class="code">encode_json e t</code> encodes <code class="code">t</code> into the
    <a href="http://erratique.ch/software/jsonm">jsonm</a> encoder <code class="code">e</code>. The
    encoding is a relatively straightforward translation of the OCaml
    structure into JSON. The main highlights are:
<p>

    <ul>
<li>OCaml <code class="code">ints</code> are translated into JSON floats.</li>
<li>OCaml strings are translated into JSON strings. You must then
       ensure that the OCaml strings contains only valid UTF-8
       characters.</li>
<li>OCaml record fields of type <code class="code"><span class="keywordsign">'</span>a option</code> are automatically
       unboxed in their JSON representation. If the value if <code class="code"><span class="constructor">None</span></code>,
       the field is removed from the JSON object.</li>
<li>variant cases built using <a href="Depyt.html#VALcase0"><code class="code"><span class="constructor">Depyt</span>.case0</code></a> are represented as strings.</li>
<li>variant cases built using <a href="Depyt.html#VALcase1"><code class="code"><span class="constructor">Depyt</span>.case1</code></a> are represented as a record
       with one field; the field name is the name of the variant.</li>
</ul>

<p>

    <b>NOTE:</b> this can be used to encode JSON fragments. That's the
    responsibility of the caller to ensure that the encoded JSON
    fragment fits properly into a well-formed JSON object.<br>
</div>

<pre><span id="VALpp_json"><span class="keyword">val</span> pp_json</span> : <code class="type">?minify:bool -> 'a <a href="Depyt.html#TYPEt">t</a> -> 'a Fmt.t</code></pre><div class="info ">
Similar to <a href="Depyt.html#VALpp"><code class="code"><span class="constructor">Depyt</span>.pp</code></a> but pretty-prints the JSON representation instead
    of the OCaml one. See <a href="Depyt.html#VALencode_json"><code class="code"><span class="constructor">Depyt</span>.encode_json</code></a> for details about the encoding.
<p>

    For instance:
<p>

    <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">type</span>&nbsp;t&nbsp;=&nbsp;{&nbsp;foo:&nbsp;int&nbsp;option;&nbsp;bar:&nbsp;string&nbsp;list&nbsp;};;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;t&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;record&nbsp;<span class="string">"r"</span>&nbsp;(<span class="keyword">fun</span>&nbsp;foo&nbsp;bar&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;{&nbsp;foo;&nbsp;bar&nbsp;})
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|+&nbsp;field&nbsp;<span class="string">"foo"</span>&nbsp;(option&nbsp;int)&nbsp;(<span class="keyword">fun</span>&nbsp;t&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;t.foo)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|+&nbsp;field&nbsp;<span class="string">"bar"</span>&nbsp;(list&nbsp;string)&nbsp;(<span class="keyword">fun</span>&nbsp;t&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;t.bar)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;sealr

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;<span class="constructor">Fmt</span>.strf&nbsp;<span class="string">"%a\n"</span>&nbsp;(pp&nbsp;t)&nbsp;{&nbsp;foo&nbsp;=&nbsp;<span class="constructor">None</span>;&nbsp;bar&nbsp;=&nbsp;[<span class="string">"foo"</span>]&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;s&nbsp;is&nbsp;"{&nbsp;foo&nbsp;=&nbsp;None;&nbsp;bar&nbsp;=&nbsp;[\"foo\"];&nbsp;}"&nbsp;*)</span>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;j&nbsp;=&nbsp;<span class="constructor">Fmt</span>.strf&nbsp;<span class="string">"%a\n"</span>&nbsp;(pp_json&nbsp;t)&nbsp;{&nbsp;foo&nbsp;=&nbsp;<span class="constructor">None</span>;&nbsp;bar&nbsp;=&nbsp;[<span class="string">"foo"</span>]&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;j&nbsp;is&nbsp;"{&nbsp;\"bar\":[\"foo\"]&nbsp;}"&nbsp;*)</span></code></pre>
<p>

    <b>NOTE:</b> this will automatically convert JSON fragments to valid
    JSON objects by adding an enclosing array if necessary.<br>
</div>
</body></html>