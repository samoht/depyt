<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Depyt (depyt.Depyt)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../index.html">depyt</a> &#x00BB; Depyt</nav><header class="odoc-preamble"><h1>Module <code><span>Depyt</span></code></h1><p>Yet-an-other type combinator library</p><p><code>Depyt</code> provides type combinators to define runtime representation for OCaml types and <a href="#generics">generic operations</a> to manipulate values with a runtime type representation.</p><p>The type combinators supports all the usual <a href="#primitives">type primitives</a> but also compact definitions of <a href="#records">records</a> and <a href="#variants">variants</a>. It also allows to define the runtime representation of <a href="#recursive">recursive types</a>.</p><p><code>Depyt</code> is a modern reboot of <a href="https://github.com/mirage/dyntype">Dyntype</a> but using <a href="https://en.wikipedia.org/wiki/Generalized_algebraic_data_type">GADT</a>s-based combinators instead of syntax-extensions. When we originally wrote <code>Dyntype</code> (in 2012) GADTs were not available in <i>OCaml</i> and <a href="https://github.com/ocaml/camlp4">camlp4</a> was everywhere -- this is not the case anymore. Finally, <code>Depyt</code> avoids some of the performance caveats present in <code>Dyntype</code> by avoiding allocating and converting between intermediate formats.</p><p><em>0.3.0 — <a href="https://github.com/samoht/depyt">homepage</a></em></p></header><nav class="odoc-toc"><ul><li><a href="#depyt">Depyt</a></li><li><a href="#primitives">Primitives</a></li><li><a href="#records">Records</a></li><li><a href="#variants">Variants</a></li><li><a href="#recursive">Recursive definitions</a></li><li><a href="#proj">Bijections</a></li><li><a href="#generics">Generic Operations</a><ul><li><a href="#binary-serialization">Binary serialization</a></li><li><a href="#json-converters">JSON converters</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="depyt"><a href="#depyt" class="anchor"></a>Depyt</h2><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span></code></div><div class="spec-doc"><p>The type for runtime representation of values of type <code>'a</code>.</p></div></div><h2 id="primitives"><a href="#primitives" class="anchor"></a>Primitives</h2><div class="odoc-spec"><div class="spec value" id="val-unit" class="anchored"><a href="#val-unit" class="anchor"></a><code><span><span class="keyword">val</span> unit : <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>unit</code> is a representation of the unit type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-bool" class="anchored"><a href="#val-bool" class="anchor"></a><code><span><span class="keyword">val</span> bool : <span>bool <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>bool</code> is a representation of the boolean type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-char" class="anchored"><a href="#val-char" class="anchor"></a><code><span><span class="keyword">val</span> char : <span>char <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>char</code> is a representation of the character type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-int" class="anchored"><a href="#val-int" class="anchor"></a><code><span><span class="keyword">val</span> int : <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>int</code> is a representation of the integer type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-int32" class="anchored"><a href="#val-int32" class="anchor"></a><code><span><span class="keyword">val</span> int32 : <span>int32 <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>int32</code> is a representation of the 32-bit integers type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-int64" class="anchored"><a href="#val-int64" class="anchor"></a><code><span><span class="keyword">val</span> int64 : <span>int64 <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>int64</code> is a representation of the 64-bit integer type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-float" class="anchored"><a href="#val-float" class="anchor"></a><code><span><span class="keyword">val</span> float : <span>float <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>float</code> is a representation of the float type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-string" class="anchored"><a href="#val-string" class="anchor"></a><code><span><span class="keyword">val</span> string : <span>string <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>string</code> is a representation of the string type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-list" class="anchored"><a href="#val-list" class="anchor"></a><code><span><span class="keyword">val</span> list : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>list t</code> is a representation of list of values of type <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-array" class="anchored"><a href="#val-array" class="anchor"></a><code><span><span class="keyword">val</span> array : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>array t</code> is a representation of array of values of type <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-option" class="anchored"><a href="#val-option" class="anchor"></a><code><span><span class="keyword">val</span> option : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> option</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>option t</code> is a representation of value of type <code>t option</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pair" class="anchored"><a href="#val-pair" class="anchor"></a><code><span><span class="keyword">val</span> pair : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>pair x y</code> is a representation of values of type <code>x * y</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-triple" class="anchored"><a href="#val-triple" class="anchor"></a><code><span><span class="keyword">val</span> triple : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'c</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span> * <span class="type-var">'c</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>triple x y z</code> is a representation of values of type <code>x * y *
    z</code>.</p></div></div><h2 id="records"><a href="#records" class="anchor"></a>Records</h2><div class="odoc-spec"><div class="spec type" id="type-field" class="anchored"><a href="#type-field" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b) field</span></span></code></div><div class="spec-doc"><p>The type for fields holding values of type <code>'b</code> and belonging to a record of type <code>'a</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-field" class="anchored"><a href="#val-field" class="anchor"></a><code><span><span class="keyword">val</span> field : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'b</span>, <span class="type-var">'a</span> )</span> <a href="#type-field">field</a></span></span></code></div><div class="spec-doc"><p><code>field n t g</code> is the representation of the field <code>n</code> of type <code>t</code> with getter <code>g</code>.</p><p>For instance:</p><pre><code>type t = { foo: string option }

let foo = field &quot;foo&quot; (option string) (fun t -&gt; t.x)</code></pre></div></div><div class="odoc-spec"><div class="spec type" id="type-open_record" class="anchored"><a href="#type-open_record" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b, 'c) open_record</span></span></code></div><div class="spec-doc"><p>The type for representing open records of type <code>'a</code> with constructors of type <code>'b</code>. <code>'c</code> represents the fields missings to the record, e.g. an open record initially holds <code>'c = 'b</code> and it can can be <a href="#val-sealr">sealed</a> when <code>'c = 'a</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sealr" class="anchored"><a href="#val-sealr" class="anchor"></a><code><span><span class="keyword">val</span> sealr : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'a</span> )</span> <a href="#type-open_record">open_record</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>sealr r</code> seal the open record <code>r</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(|+)" class="anchored"><a href="#val-(|+)" class="anchor"></a><code><span><span class="keyword">val</span> (|+) : 
  <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span>, <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'d</span> )</span> <a href="#type-open_record">open_record</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'c</span> )</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'d</span> )</span> <a href="#type-open_record">open_record</a></span></span></code></div><div class="spec-doc"><p><code>r |+ f</code> adds the field <code>f</code> to the open record <code>r</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-record" class="anchored"><a href="#val-record" class="anchor"></a><code><span><span class="keyword">val</span> record : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'b</span> )</span> <a href="#type-open_record">open_record</a></span></span></code></div><div class="spec-doc"><p><code>record n f fs</code> is the representation of the record called <code>n</code> of type <code>'a</code> using <code>f</code> as constructor and with the fields <code>fs</code>.</p><p>Putting all together:</p><pre><code>type t = { foo: string; bar = (int * string) list; }

let t =
  record &quot;t&quot; (fun foo -&gt; { foo })
  |+ field &quot;foo&quot; string (fun t -&gt; t.foo)
  |+ field &quot;bar&quot; (list (pair int string)) (fun t -&gt; t.bar)
  |&gt; sealr</code></pre></div></div><h2 id="variants"><a href="#variants" class="anchor"></a>Variants</h2><div class="odoc-spec"><div class="spec type" id="type-case" class="anchored"><a href="#type-case" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b) case</span></span></code></div><div class="spec-doc"><p>The type for representing variant cases of type <code>'a</code> with patterns of type <code>'b</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-case_p" class="anchored"><a href="#type-case_p" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a case_p</span></span></code></div><div class="spec-doc"><p>The type for representing patterns for a variant of type <code>'a</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-case0" class="anchored"><a href="#val-case0" class="anchor"></a><code><span><span class="keyword">val</span> case0 : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'a</span>, <span><span class="type-var">'a</span> <a href="#type-case_p">case_p</a></span> )</span> <a href="#type-case">case</a></span></span></code></div><div class="spec-doc"><p><code>case0 n v</code> is a representation of a variant case <code>n</code> with no argument and a singleton pattern. e.g.</p><pre><code>type t = Foo

let foo = case0 &quot;Foo&quot; Foo</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-case1" class="anchored"><a href="#val-case1" class="anchor"></a><code><span><span class="keyword">val</span> case1 : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'a</span>, <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-case_p">case_p</a></span> )</span> <a href="#type-case">case</a></span></span></code></div><div class="spec-doc"><p><code>case1 n t c</code> is a representation of a variant case <code>n</code> with 1 argument of type <code>t</code> and a pattern <code>c</code> an function with one argument of type <code>t</code>. e.g.</p><pre><code>type t = Foo of string

let foo = case1 &quot;Foo&quot; string (fun s -&gt; Foo s)</code></pre></div></div><div class="odoc-spec"><div class="spec type" id="type-open_variant" class="anchored"><a href="#type-open_variant" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b, 'c) open_variant</span></span></code></div><div class="spec-doc"><p>The type for representing open variants of type <code>'a</code> with pattern matching of type <code>'b</code>. <code>'c</code> represents the missing cases for the variant, e.g. initially variant hols <code>c' = 'b</code> and it can be <a href="#val-sealv">sealed</a> when <code>'c = 'a</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sealv" class="anchored"><a href="#val-sealv" class="anchor"></a><code><span><span class="keyword">val</span> sealv : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span>, <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-case_p">case_p</a></span> )</span> <a href="#type-open_variant">open_variant</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>sealv v</code> seals the open variant <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(|~)" class="anchored"><a href="#val-(|~)" class="anchor"></a><code><span><span class="keyword">val</span> (|~) : 
  <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span>, <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'d</span> )</span> <a href="#type-open_variant">open_variant</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'c</span> )</span> <a href="#type-case">case</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'d</span> )</span> <a href="#type-open_variant">open_variant</a></span></span></code></div><div class="spec-doc"><p><code>v |~ c</code> is <code>v</code> augmented with the case <code>c</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-variant" class="anchored"><a href="#val-variant" class="anchor"></a><code><span><span class="keyword">val</span> variant : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'b</span> )</span> <a href="#type-open_variant">open_variant</a></span></span></code></div><div class="spec-doc"><p><code>variant n c p</code> is a representation of a variant type containing the cases <code>c</code> and using <code>p</code> to deconstruct values.</p><p>Putting all together:</p><pre><code>type t = Foo | Bar of string

let t =
  variant &quot;t&quot; (fun foo bar -&gt; function
    | Foo   -&gt; foo
    | Bar s -&gt; bar s)
  |~ case0 &quot;Foo&quot; Foo
  |~ case1 &quot;Bar&quot; string (fun x -&gt; Bar x)
  |&gt; sealr</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-enum" class="anchored"><a href="#val-enum" class="anchor"></a><code><span><span class="keyword">val</span> enum : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span>(string * <span class="type-var">'a</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>enum n l</code> is a representation of the variant type which has only constant variant case. e.g.</p><pre><code>type t = Foo | Bar | Toto

let t = enum &quot;t&quot; [&quot;Foo&quot;, Foo; &quot;Bar&quot;, Bar; &quot;Toto&quot;, Toto]</code></pre></div></div><h2 id="recursive"><a href="#recursive" class="anchor"></a>Recursive definitions</h2><p><code>Depyt</code> allows to create a limited form of recursive records and variants.</p><p><b>TODO</b>: describe the limitations, e.g. only regular recursion and no use of the generics inside the <code>mu*</code> functions and the usual caveats with recursive values (such as infinite loops on most of the generics which don't check sharing).</p><div class="odoc-spec"><div class="spec value" id="val-mu" class="anchored"><a href="#val-mu" class="anchor"></a><code><span><span class="keyword">val</span> mu : <span><span>( <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>mu f</code> is the representation <code>r</code> such that <code>r = mu r</code>.</p><p>For instance:</p><pre><code>type x = { x: x option }

let x = mu (fun x -&gt;
    record &quot;x&quot; (fun x -&gt; { x })
    |+ field &quot;x&quot; x (fun x -&gt; x.x)
    |&gt; sealr)</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-mu2" class="anchored"><a href="#val-mu2" class="anchor"></a><code><span><span class="keyword">val</span> mu2 : <span><span>( <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>mu2 f</code> is the representations <code>r</code> and <code>s</code> such that <code>r, s = mu2 r
    s</code>.</p><p>For instance:</p><pre><code>type r = { foo: int; bar: string list; z: z option }
and z = { x: int; r: r list }

(* Build the representation of [r] knowing [z]'s. *)
let mkr z =
  record &quot;r&quot; (fun foo bar z -&gt; { foo; bar; z })
  |+ field &quot;foo&quot; int (fun t -&gt; t.foo)
  |+ field &quot;bar&quot; (list string) (fun t -&gt; t.bar)
  |+ field &quot;z&quot; (option z) (fun t -&gt; t.z)
  |&gt; sealr

(* And the representation of [z] knowing [r]'s. *)
let mkz r =
  record &quot;z&quot; (fun x r -&gt; { x; r })
  |+ field &quot;x&quot; int (fun t -&gt; t.x)
  |+ field &quot;r&quot; (list r) (fun t -&gt; t.r)
  |&gt; sealr

(* Tie the loop. *)
let r, z = mu2 (fun r z -&gt; mkr z, mkz y)</code></pre></div></div><h2 id="proj"><a href="#proj" class="anchor"></a>Bijections</h2><p>Sometimes it is not always possible to describe precisely a type (or it could be too tedious) and it is easier to describe the relation with an other know type. This is what bijections are about.</p><div class="odoc-spec"><div class="spec value" id="val-like" class="anchored"><a href="#val-like" class="anchor"></a><code><span><span class="keyword">val</span> like : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>like x f g</code> is the description of a type which looks like <code>x</code> using the bijetion <code>(f, g)</code>.</p></div></div><h2 id="generics"><a href="#generics" class="anchor"></a>Generic Operations</h2><p>Given a value <code>'a t</code>, it is possible to define generic operations on value of type <code>'a</code> such as pretty-printing, parsing and unparsing.</p><div class="odoc-spec"><div class="spec value" id="val-dump" class="anchored"><a href="#val-dump" class="anchor"></a><code><span><span class="keyword">val</span> dump : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Fmt</span>.t</span></span></code></div><div class="spec-doc"><p><code>dump t</code> dumps the values of type <code>t</code> as a parsable OCaml expression.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal t</code> is the equality function between values of type <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare" class="anchored"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>compare t</code> compares values of type <code>t</code>.</p></div></div><h3 id="binary-serialization"><a href="#binary-serialization" class="anchor"></a>Binary serialization</h3><div class="odoc-spec"><div class="spec type" id="type-buffer" class="anchored"><a href="#type-buffer" class="anchor"></a><code><span><span class="keyword">type</span> buffer</span><span> = </span></code><table><tr id="type-buffer.C" class="anchored"><td class="def variant constructor"><a href="#type-buffer.C" class="anchor"></a><code><span>| </span><span><span class="constructor">C</span> <span class="keyword">of</span> <span class="xref-unresolved">Cstruct</span>.t</span></code></td></tr><tr id="type-buffer.B" class="anchored"><td class="def variant constructor"><a href="#type-buffer.B" class="anchor"></a><code><span>| </span><span><span class="constructor">B</span> <span class="keyword">of</span> bytes</span></code></td></tr></table></div><div class="spec-doc"><p>The type for buffers.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-size_of" class="anchored"><a href="#val-size_of" class="anchor"></a><code><span><span class="keyword">val</span> size_of : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>size_of t</code> is the size needed to serialize values of type <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-write" class="anchored"><a href="#val-write" class="anchor"></a><code><span><span class="keyword">val</span> write : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-buffer">buffer</a> <span class="arrow">&#45;&gt;</span></span> <span>pos:int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>write t</code> serializes values of type <code>t</code>. Use <code>size_of</code> to pre-determine the size of the buffer.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-read" class="anchored"><a href="#val-read" class="anchor"></a><code><span><span class="keyword">val</span> read : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-buffer">buffer</a> <span class="arrow">&#45;&gt;</span></span> <span>pos:int <span class="arrow">&#45;&gt;</span></span> int * <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>read t</code> reads a serialization of a value of type <code>t</code>.</p></div></div><h3 id="json-converters"><a href="#json-converters" class="anchor"></a>JSON converters</h3><div class="odoc-spec"><div class="spec value" id="val-pp_json" class="anchored"><a href="#val-pp_json" class="anchor"></a><code><span><span class="keyword">val</span> pp_json : <span>?minify:bool <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Fmt</span>.t</span></span></code></div><div class="spec-doc"><p>Similar to <a href="#val-dump"><code>dump</code></a> but pretty-prints the JSON representation instead of the OCaml one. See <a href="#val-encode_json"><code>encode_json</code></a> for details about the encoding.</p><p>For instance:</p><pre><code>type t = { foo: int option; bar: string list };;

let t =
  record &quot;r&quot; (fun foo bar -&gt; { foo; bar })
  |+ field &quot;foo&quot; (option int) (fun t -&gt; t.foo)
  |+ field &quot;bar&quot; (list string) (fun t -&gt; t.bar)
  |&gt; sealr

let s = Fmt.str &quot;%a\n&quot; (pp t) { foo = None; bar = [&quot;foo&quot;] }
(* s is &quot;{ foo = None; bar = [\&quot;foo\&quot;]; }&quot; *)

let j = Fmt.str &quot;%a\n&quot; (pp_json t) { foo = None; bar = [&quot;foo&quot;] }
(* j is &quot;{ \&quot;bar\&quot;:[\&quot;foo\&quot;] }&quot; *)</code></pre><p><b>NOTE:</b> this will automatically convert JSON fragments to valid JSON objects by adding an enclosing array if necessary.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-encode_json" class="anchored"><a href="#val-encode_json" class="anchor"></a><code><span><span class="keyword">val</span> encode_json : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Jsonm</span>.encoder <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>encode_json t e</code> encodes <code>t</code> into the <a href="http://erratique.ch/software/jsonm">jsonm</a> encoder <code>e</code>. The encoding is a relatively straightforward translation of the OCaml structure into JSON. The main highlights are:</p><ul><li>OCaml <code>ints</code> are translated into JSON floats.</li><li>OCaml strings are translated into JSON strings. You must then ensure that the OCaml strings contains only valid UTF-8 characters.</li><li>OCaml record fields of type <code>'a option</code> are automatically unboxed in their JSON representation. If the value if <code>None</code>, the field is removed from the JSON object.</li><li>variant cases built using <a href="#val-case0"><code>case0</code></a> are represented as strings.</li><li>variant cases built using <a href="#val-case1"><code>case1</code></a> are represented as a record with one field; the field name is the name of the variant.</li></ul><p><b>NOTE:</b> this can be used to encode JSON fragments. That's the responsibility of the caller to ensure that the encoded JSON fragment fits properly into a well-formed JSON object.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-decode_json" class="anchored"><a href="#val-decode_json" class="anchor"></a><code><span><span class="keyword">val</span> decode_json : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Jsonm</span>.decoder <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'a</span>, string )</span> <span class="xref-unresolved">Stdlib</span>.Result.t</span></span></code></div><div class="spec-doc"><p><code>decode_json t e</code> decodes values of type <code>t</code> from the <a href="http://erratique.ch/software/jsonm">jsonm</a> decoder <code>e</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-decode_json_lexemes" class="anchored"><a href="#val-decode_json_lexemes" class="anchor"></a><code><span><span class="keyword">val</span> decode_json_lexemes : 
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="xref-unresolved">Jsonm</span>.lexeme list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'a</span>, string )</span> <span class="xref-unresolved">Stdlib</span>.Result.t</span></span></code></div><div class="spec-doc"><p><code>decode_json_lexemes</code> is similar to <a href="#val-decode_json"><code>decode_json</code></a> but use an already decoded list of JSON lexemes instead of a decoder.</p></div></div></div></body></html>